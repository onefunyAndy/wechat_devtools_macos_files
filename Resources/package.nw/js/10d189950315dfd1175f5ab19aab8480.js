exports.gitassistant=function(e){var t={};function a(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,a),n.l=!0,n.exports}return a.m=e,a.c=t,a.d=function(e,t,r){a.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},a.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.t=function(e,t){if(1&t&&(e=a(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(a.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)a.d(r,n,function(t){return e[t]}.bind(null,n));return r},a.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return a.d(t,"a",t),t},a.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},a.p="/dist/",a(a.s=22)}([function(e,t){e.exports=require("nodegit")},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={i:console.log.bind(console),w:console.warn.bind(console),e:console.error.bind(console)}},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("lodash")},function(e,t,a){"use strict";function r(e){return Object.prototype.toString.call(e).toLowerCase().slice(8,-1)}function n(e){const t=r(e);return"string"===t||"regexp"===t||"boolean"===t||"number"===t||"symbol"===t||"undefined"===t||"null"===t}Object.defineProperty(t,"__esModule",{value:!0}),t.normalizePath=function(e,t,a){let r=(e||"").replace(/\\{1,}/g,"/");return"string"==typeof t&&(r=r.startsWith(t)?r:t+r),"string"==typeof a&&(r=r.endsWith(a)?r:r+a),r},t.getType=r,t.isPrimitive=n,t.toStringIfPossible=function e(t){return t?n(t)?""+t:"function"==typeof t.toString?t.toString():"function"==typeof t[Symbol.toPrimitive]?e(t[Symbol.toPrimitive]()):""+t:""},t.safeInvoke=function(e,t,a){return"function"==typeof e?e.bind(t):()=>a}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(3),n=a(1);var i=a(28);t.getCommitRecordFromCommit=i.fromCommit,t.commit=async function(e,t,a){n.default.i("committing");const i=await t.writeTree(),o=await e.getHeadCommit(),s=await e.defaultSignature();return await e.createCommit("HEAD",s,s,a,i,r.compact([o]))}},function(e,t){e.exports=require("fs")},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(6),i=a(2),o=a(3),s=a(26);var c=a(13);t.DiffType=c.DiffType;const u=a(10),l=a(4),f=a(1),d=a(5);async function m(e){if(!e.isMerging()&&!e.isRebasing())return;let t;if(e.isMerging())t=await new Promise(t=>e.mergeheadForeach(t));else{const a=await r.Rebase.open(e),n=a.operationCurrent();t=a.operationByIndex(n).id()}const a=await e.getReference("HEAD"),n=l.toStringIfPossible(a.target());try{const a=await r.Commit.lookup(e,n),i=await r.Commit.lookup(e,t);return await r.Merge.commits(e,a,i)}catch(e){return void f.default.e(e)}}async function p(e){const t=await m(e);if(t){const e=o.filter(t.entries(),r.Index.entryIsConflict).map(e=>e.path());return o.uniq(e)}return[]}t.getPossibleConflictedIndex=m,t.getOriginallyConflictedFiles=p,t.getStatus=async function(e){const t=await u.getSubmoduleRecords(e),a=t.length>0;let o=[];if(e.isRebasing())try{n.statSync(i.join(e.path(),"rebase-apply")),o=[]}catch(t){console.warn(t),o=await p(e)}else e.isMerging()&&(o=await p(e));const c=await e.index(),m=await e.getStatusExt();let w=!1;const h={},g=[];for(const r of m){const u=s.fromStatus(r),l=o.includes(u.name),f=l&&!u.isConflicted;w=w||f,u.originallyConflicted=l;let d=!1;if(a&&(u.path=u.path.replace(/\/$/,""),u.name=u.name.replace(/\/$/,""),d=t.findIndex(e=>e.path===u.path)>=0),u.submoduleCommit={staged:s.isSubmoduleCommit(u.fileModes.staged.old,u.fileModes.staged.new),unstaged:d||s.isSubmoduleCommit(u.fileModes.unstaged.old,u.fileModes.unstaged.new)},u.isSubmoduleCommit=Boolean(u.submoduleCommit.unstaged)||Boolean(u.submoduleCommit.staged),u.isConflicted){const t=await c.conflictGet(u.name);if(t.ancestor_out&&!t.our_out&&t.their_out&&n.existsSync(i.join(e.workdir(),u.name)))throw new Error("file "+u.name+" still exists while deleted in a conflicts")}h[u.name]=u,u.isConflicted&&g.push(u)}for(const n of g){const i=await c.conflictGet(n.name);if(n.indexEntries={ancestor:{entry:i.ancestor_out,commit:null},ours:{entry:i.our_out,commit:null},theirs:{entry:i.their_out,commit:null}},a&&t.find(e=>e.path===n.path)&&n.indexEntries)try{const t=await r.Submodule.lookup(e,n.path),a=await t.open();if(n.indexEntries.ancestor.entry&&"string"!=typeof n.indexEntries.ancestor.entry){const e=await a.getCommit(n.indexEntries.ancestor.entry.id);n.indexEntries.ancestor.commit=await d.getCommitRecordFromCommit(e),n.indexEntries.ancestor.entry=l.toStringIfPossible(n.indexEntries.ancestor.entry.id)}if(n.indexEntries.ours.entry&&"string"!=typeof n.indexEntries.ours.entry){const e=await a.getCommit(n.indexEntries.ours.entry.id);n.indexEntries.ours.commit=await d.getCommitRecordFromCommit(e),n.indexEntries.ours.entry=l.toStringIfPossible(n.indexEntries.ours.entry.id)}if(n.indexEntries.theirs.entry&&"string"!=typeof n.indexEntries.theirs.entry){const e=await a.getCommit(n.indexEntries.theirs.entry.id);n.indexEntries.theirs.commit=await d.getCommitRecordFromCommit(e),n.indexEntries.theirs.entry=l.toStringIfPossible(n.indexEntries.theirs.entry.id)}}catch(e){f.default.e("get status open submodule fail",e)}}if(e.isRebasing()){const t=await r.Rebase.open(e),a=t.operationCurrent()+1,n=t.operationEntrycount(),i=t.operationByIndex(t.operationCurrent()),o=i&&i.id(),s=o?await e.getCommit(o):null;console.log("rebasing",s?s.summary():s,s?s.message():s,a,n)}return{hasUnresolvedConflicts:Boolean(c.hasConflicts()),hasResolvedConflicts:w,changes:h}}},function(e,t){e.exports=require("fs-extra")},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.Unknown="Unknown",e.Local="Local",e.Remote="Remote",e.Tag="Tag"}(t.BranchType||(t.BranchType={})),function(e){e.UpToDate="UpToDate",e.FastForward="FastForward",e.Normal="Normal"}(t.MergeState||(t.MergeState={})),function(e){e.Fetch="Fetch",e.Merge="Merge",e.FF_Only="FF_Only",e.Rebase="Rebase"}(t.PullType||(t.PullType={})),t.LocalBranchPrefix="refs/heads/",t.RemoteBranchPrefix="refs/remotes/",t.TagPrefix="refs/tags/"},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(27),i=a(3);async function o(e){return await e.getSubmoduleNames()}t.getSubmoduleNames=o,t.getSubmoduleRecords=async function(e){const t=await o(e),a=await Promise.all(t.map(t=>r.Submodule.lookup(e,t))),s=await Promise.all(a.map(e=>n.fromSubmodule(e)));return i.compact(s)}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(14),i=a(7),o=a(4),s=a(3),c=a(6),u=a(2);async function l(e,t){const a=await i.getStatus(e),o=[];for(const e of t){const t=a.changes[e];if(t&&t.oldFileName){const e=t.oldFileName;o.push(e)}o.push(e)}n.deleteLock(e);const s=await e.getHeadCommit();return o.length?await r.Reset.default(e,s,o):await r.Reset.default(e,s),o}t.unstage=l,t.stage=async function(e,t){n.deleteLock(e);const a=await e.index(),i=[];for(const n of t)i.push(r.Status.file(e,n).then(e=>512&e?a.removeByPath(n):a.addByPath(n)));await Promise.all(i),await a.write()},t.stageAllChanges=async function(e){n.deleteLock(e);const t=await e.index();await t.updateAll("*")},t.addAll=async function(e){n.deleteLock(e);const t=await e.index();await t.addAll("*",0),await t.write()},t.unstageWorkdirChanges=async function(e,t){if(!t){const a=await i.getStatus(e);t=s.values(a.changes)}const a=s.compact(t).map(e=>e.path);await l(e,a)},t.stageWorkdirChanges=async function(e,t){if(!t){const a=await i.getStatus(e);t=s.values(a.changes)}const a=s.compact(t),r=await e.index();for(const t of a){const a=o.normalizePath(t.path);if(t.isConflicted)try{c.statSync(u.join(e.workdir(),a)),await r.addByPath(a)}catch(e){await r.removeByPath(a)}else t.unstagedStatus===i.DiffType.DELETED?await r.removeByPath(a):await r.addByPath(a)}await r.write()}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(1);let i=new Map;const o=3e5;t.freeAll=async function(){i.forEach(e=>{e.returned&&e.repo.free()}),i=new Map};const s=[];function c(e){try{e.cleanup(),e.free()}catch(e){n.default.w(e)}}t.default=function(e){return new Promise(async(t,a)=>{const n=i.get(e);let o;if(n){if(!n.returned)return void s.push({resolve:t,reject:a});o=n.repo}else try{o=await r.Repository.open(e)}catch(e){return a(e)}return i.set(e,{repo:o,accessTime:Date.now(),returned:!1}),t(o)})},t.returnBack=function(e){const t=i.get(e);if(t&&!t.returned){const a=s.shift();a&&a.resolve(t.repo),i.set(e,{repo:t.repo,accessTime:Date.now(),returned:!a})}},t.save=function(e,t){i.set(e,{returned:!1,repo:t,accessTime:Date.now()})},function e(){const t=Date.now(),a=[];for(const[e,r]of i)r.returned&&t-r.accessTime>o&&(n.default.i(e,"repo shall be auto released"),c(r.repo),a.push(e));for(const e of a)i.delete(e);setTimeout(e,o)}()},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.ADDED="added",e.CONFLICT="conflict",e.CURRENT="current",e.DELETED="deleted",e.DIRECTORY="directory",e.MODIFIED="modified",e.RENAMED="renamed",e.RESOLVED="resolved"}(t.DiffType||(t.DiffType={}))},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(8),n=a(2),i=a(1);t.deleteLock=function(e){const t=n.join(e.path(),"index.lock");r.existsSync(t)&&(i.default.i("index.lock detected"),r.unlinkSync(t))}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.Unknown="Unknown",e.Added="Added",e.Deleted="Deleted",e.Modified="Modified",e.Conflict="Conflict",e.Renamed="Renamed"}(t.DiffTypes||(t.DiffTypes={})),function(e){e.Unknown="Unknown",e.Added="Added",e.Deleted="Deleted",e.NotModified="NotModified"}(t.LineTypes||(t.LineTypes={}))},function(e,t,a){"use strict";function r(e){for(var a in e)t.hasOwnProperty(a)||(t[a]=e[a])}Object.defineProperty(t,"__esModule",{value:!0});const n=a(0),i=a(3),o=a(4),s=a(38),c=a(5),u=a(1);r(a(17));const l=a(17),f=a(18),d=a(21);async function m(e){return await e.getReferenceNames(3)}async function p(e){return(await e.getRemotes()).map(e=>"string"==typeof e?e:e&&"function"==typeof e.name?e.name():"?")}async function w(e,t,a,r){const n=await e.getRemote(t);if(!n)throw new Error("cannot find repo "+t);const i=await f.getProxyOptsForRemote(e,t,n.url(),r.appProxyUrl,r.proxyType),o=new Promise(async(o,s)=>{try{const c=await f.getRemoteOptions(e,{certificateCheck:r.certificateCheck,processCallback:r.processCallback,pushUpdateRejector:s,credentialRejector:s,proxyOpts:i,credentialType:r.credentialType,userPassCredentialDetail:r.userPassCredentialDetail,sshCredentialDetail:r.sshCredentialDetail});await n.fetch(a||null,c,`Fetch ${a?a.join(", "):"ALL"} from ${t}`),o()}catch(e){s(e)}});await o}async function h(e,t,a,r){const c=await e.head();if(c.name()!==t)throw new Error("You can only merge into an active branch (checkout)");const u=await e.getReference(t),l=await e.getReference(a);if(!u||!l)throw new Error(`cannot find refs to merge ${t} <-> ${a}`);const f=await e.getStatus();let m=null,p=null;if(f&&f.length>0){m=await d.stash(e,`Auto stash for merge ${a} -> ${t}`);const r=await d.getStashes(e),n=o.toStringIfPossible(m);for(let e=0;e<r.length;e++)if(r[e].sha===n){p=r[e].index;break}}const w=async()=>{if("number"==typeof p){const t=p;p=null,await d.apply(e,t,!0)}};try{let o;const u=await s.getMergeState(e,c.target(),l.target());if(u===s.MergeState.UpToDate)return void await w();if(u===s.MergeState.FastForward&&1!==r.preference)o="FF";else{if(2===r.preference)throw new Error("Branch cannot be fast-forwarded");o="Merge"}let f,d=null;if("FF"===o){const t=await e.getBranchCommit(l),a=await t.getTree();await n.Checkout.tree(e,a,{checkoutStrategy:5});const r=await e.getBranch(c);await r.setTarget(l.target(),`Fast-Forward ${c.name()}, ${l.name()}`),f=await l.target()}else{const t=await n.AnnotatedCommit.fromRef(e,l);await n.Merge.merge(e,t,null,{checkoutStrategy:5});const a=await e.index();a&&a.hasConflicts()&&(d=a)}if("Merge"===o&&!d){if(!e.isMerging())throw new Error("No merge in progress");const r=await e.index();if(r.hasConflicts())throw new Error("Cannot merge, has unresolved conflicts");const n=await e.getHeadCommit(),o=await e.getBranchCommit("MERGE_HEAD"),s=await e.defaultSignature(),c=await r.writeTree();f=await e.createCommit("HEAD",s,s,`Merge ${a} into ${t}`,c,i.compact([n,o])),await e.stateCleanup()}d||await w()}catch(e){throw await w(),new Error(e)}}async function g(e,t){const a=await p(e);for(const e of a)if(t.startsWith(s.RemoteBranchPrefix+e+"/"))return e;return null}async function y(e,t,a,r){const n=await e.getReference(a),i=await e.getReference(t);if(!n||!i)throw new Error("Cannot find refs to rebase");if((await e.head()).name()!==t)throw new Error(`Checkout to ${t} before rebase`);const c=await e.getStatus();let l=null,f=null;if(c&&c.length>0){l=await d.stash(e,`Auto stash for rebase ${t} and ${a}`);const r=await d.getStashes(e),n=o.toStringIfPossible(l);for(let e=0;e<r.length;e++)if(r[e].sha===n){f=r[e].index;break}}const m=async()=>{if("number"==typeof f){const t=f;f=null,await d.apply(e,t,!0)}};try{await e.rebaseBranches(t,a,null,e.defaultSignature(),e=>{s.rebaseReleaseObjCallback(r.processCallback,e)},e=>{const t=(e=e||{}).rewritten;u.default.i(t)}),await m()}catch(e){throw new Error(e)}}r(a(9)),t.getAllRefCommits=async function(e){const t=await e.getReferenceNames(3),a={};for(const r of t)try{const t=await e.getReference(r),i=(await t.peel(n.Object.TYPE.COMMIT)).id(),o=await e.getCommit(i),s=await c.getCommitRecordFromCommit(o);s.refFullName=r,a[r]=s}catch(e){u.default.e(e)}if(!a.HEAD){const t=await e.getHeadCommit();if(t){const e=await c.getCommitRecordFromCommit(t);e&&(a.HEAD=e)}}return a},t.getAllRefNames=m,t.getRemoteRefNames=p,t.getRefNamesOrdered=async function(e){const t=await m(e),a=await p(e),r=[],i={},o={};for(const t of a){i[t]=[];const a=await e.getRemote(t),r={name:a.name(),fetchRefspecs:await a.getFetchRefspecs(),pushRefspecs:await a.getPushRefspecs(),pushurl:a.pushurl(),url:a.url()};o[t]=r}const c=[],l={},f={};for(const o of t)if(o)if(o.startsWith(s.LocalBranchPrefix)){r.push(o.replace(s.LocalBranchPrefix,""));const t=await e.getReference(o);if(t.isBranch())try{const a=await n.Branch.upstream(t);l[o]=a.name(),f[o]=await n.Graph.aheadBehind(e,t.target(),a.target())}catch(e){console.warn(e)}}else if(o.startsWith(s.TagPrefix))c.push(o.replace(s.TagPrefix,""));else if(o.startsWith(s.RemoteBranchPrefix))for(const e of a){const t=s.RemoteBranchPrefix+e+"/";if(o.startsWith(t)){(i[e]=i[e]||[]).push(o.replace(t,""));break}}let d=null;try{d=await e.getReference("HEAD")}catch(e){u.default.e(e)}return{locals:r,remotes:i,tags:c,trackMaps:l,aheadBehinds:f,headRefFullName:d?d.name():"",remoteConfigs:o}},t.fetch=w,t.merge=h,t.mergeAbort=async function(e){if(!e.isMerging())throw new Error("Repo is not merging");if(0!==e.stateCleanup())throw new Error("cannot cleanup repo state");{const t=await e.getHeadCommit();await n.Reset.reset(e,t,3,{})}},t.getRemoteOriginNameFromRemoteRefFullName=g,t.pull=async function(e,t,a){const r=(await e.head()).name();if(!(await n.Reference.lookup(e,r)).isBranch())throw new Error(`${r} is not a branch`);let i=await e.getReference(t);if(!i)throw new Error(`Cannot find ${t}`);if(!i.isRemote())throw new Error(`${t} is not a remote ref`);if(t=i.name(),i.isRemote()){const r=await g(e,t);if(!r)throw new Error("Cannot find remote name for "+t);await w(e,r,null,a.fetchOptions)}i=null;try{i=await e.getReference(t)}catch(e){u.default.e(e)}if(!i)throw new Error(`Cannot find upstream for ${r}, maybe it's been removed.`);a.type===s.PullType.Merge?await h(e,r,t,{preference:0}):a.type===s.PullType.FF_Only?await h(e,r,t,{preference:2}):a.type===s.PullType.Rebase&&await y(e,r,t,{processCallback:a.rebaseProcessCallback?a.rebaseProcessCallback:()=>{}})},t.push=async function(e,t,a,r){const i=await n.Reference.lookup(e,t);if(!i||!i.isBranch())throw new Error(`${t} is not a branch`);const o=l.getShortName(a),c=await g(e,a);if(!c)throw new Error("cannot find remote named "+c);const u=await e.getRemote(c),d=s.LocalBranchPrefix+o.replace(`${c}/`,""),m=new Promise(async(a,n)=>{try{const i=await f.getProxyOptsForRemote(e,c,u.pushurl()||u.url(),r.appProxyUrl,r.proxyType),o=await f.getRemoteOptions(e,{certificateCheck:r.certificateCheck,processCallback:r.processCallback,pushUpdateRejector:n,credentialRejector:n,proxyOpts:i,credentialType:r.credentialType,userPassCredentialDetail:r.userPassCredentialDetail,sshCredentialDetail:r.sshCredentialDetail});await u.push(`${r.force?"+":""}${t}:${d}`,o),a()}catch(e){n(e)}});await m},t.pushTag=async function(e,t,a,r){const n=await e.getRemote(a);if(!n)throw new Error("Cannot find remote named "+a);const i=await e.getReference(t);if(!i)throw new Error("Cannot find tag "+i);const o=await f.getProxyOptsForRemote(e,a,n.pushurl()||n.url(),r.appProxyUrl,r.proxyType),s=new Promise(async(a,i)=>{try{const s=await f.getRemoteOptions(e,{certificateCheck:r.certificateCheck,processCallback:r.processCallback,pushUpdateRejector:i,credentialRejector:i,proxyOpts:o,credentialType:r.credentialType,userPassCredentialDetail:r.userPassCredentialDetail});await n.push(`${t}:${t}`,s),a()}catch(e){i(e)}});await s},t.rebase=y,t.rebaseAbort=async function(e){if(!e.isRebasing())throw new Error("Repo is not rebasing");const t=await n.Rebase.open(e);if(!t)throw new Error("Cannot open rebase for repo");await t.abort()},t.rebaseContinue=async function(e,t){if(!e.isRebasing())throw new Error("Repo is not rebasing");if((await e.index()).hasConflicts())throw new Error("Repo has unresolved conflicts, cannot continue rebasing");await e.continueRebase(e.defaultSignature(),e=>{s.rebaseReleaseObjCallback(t.processCallback,e)})},t.reset=async function(e,t,a){const r=await e.getCommit(t);await n.Reset.reset(e,r,a.type,{})},t.setUpstream=async function(e,t,a){const r=await e.getBranch(t);if(!a)return void await n.Branch.setUpstream(r,null);const i=await e.getReference(a);if(!r||!i)throw r?new Error(`Cannot find remote ref ${a}`):i?new Error(`Cannot find local ref ${t}`):new Error(`Cannot find refs ${t} and ${a}`);const o=await g(e,a),c=`${o}/${a.replace(s.RemoteBranchPrefix+o+"/","")}`;await n.Branch.setUpstream(r,c)},t.addRemote=async function(e,t,a,r){r?await n.Remote.createWithFetchspec(e,t,a,r):await n.Remote.create(e,t,a)}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(9);function i(e){return e.replace(new RegExp(`^(${n.TagPrefix})|(${n.LocalBranchPrefix})|(${n.RemoteBranchPrefix})`),"")}async function o(e,t){const a=(await e.getRemotes()).map(e=>"string"==typeof e?e:e&&"function"==typeof e.name?e.name():"?");for(const e of a){const a=n.RemoteBranchPrefix+e+"/";if(t.startsWith(a))return e}return""}function s(e){if("string"!=typeof e){if(e.isBranch())return n.BranchType.Local;if(e.isRemote())return n.BranchType.Remote;if(e.isTag())return n.BranchType.Tag}const t="string"==typeof e?e:e.name();return t.startsWith(n.RemoteBranchPrefix)?n.BranchType.Remote:t.startsWith(n.LocalBranchPrefix)?n.BranchType.Local:t.startsWith(n.TagPrefix)?n.BranchType.Tag:n.BranchType.Unknown}t.getShortName=i,t.getRemoteName=o,t.getBranchType=s,t.checkout=async function(e,t){const a=await e.head();if((await e.getReferenceNames(3)).indexOf(t)<0)throw new Error("cannot checkout to an non-exists branch");if(a.name()===t)return t;if(s(t)!==n.BranchType.Local)throw new Error("cannot checkout to a non-local branch");const r=await e.checkoutBranch(t,{checkoutStrategy:1});return r?r.name():t},t.create=async function(e,t,a,o){if((await e.getReferenceNames(3)).includes(t))throw new Error("cannot create an existing branch");let s;try{s=await r.Commit.lookup(e,a)}catch(e){throw new Error("commit sha dose not exists "+a)}const c=t.startsWith(n.TagPrefix),u=i(t),l=await r.Reference.create(e,t,s.id(),0,`Create ${u} (${t})`);if(!c&&o)try{await r.Branch.setUpstream(l,o)}catch(e){throw new Error("cannot set upstream for "+t+" to "+o)}},t.delete_=async function(e,t){const a=await r.Reference.lookup(e,t);if(!a)throw new Error("cannot find ref for "+t);if((await e.head()).name()===t)throw new Error("cannot delete an active branch");const i=s(a);if(i===n.BranchType.Tag)await a.delete();else if(i===n.BranchType.Local)await a.delete();else if(i===n.BranchType.Remote){const a=await o(e,t);if(!a)throw new Error("no remote found for "+a);const r=await e.getRemote(a);await r.push([`:${t}`])}}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(19),i=a(1),o=a(2),s=a(6),c=a(20);var u=a(20);async function l(e){let t;try{t=await e.config()}catch(e){t=await r.Config.openDefault()}return t}t.getCredentialStore=u.getCredentialStore,t.setConfigForRepo=async function(e,t){const a=await l(e);if(!a)throw new Error("Cannot find config for repository");for(const e of t)await a.setString(e.key,e.value)},t.getConfigForRepo=l,t.getRepoConfigOverviewForRepo=async function(e){const t=await l(e),a=e.workdir().replace(/\\/g,"").replace(/^\/|\/$/g,"").split("/");let r="";a&&a.length>0&&(r=a[a.length-1]);let n="";try{n=await t.getString("user.email")}catch(e){i.default.e(e)}n||(n=e.defaultSignature().email());let c="";try{c=await t.getString("user.name")}catch(e){i.default.e(e)}c||(c=e.defaultSignature().name());const u=o.join(e.workdir(),".gitignore");let f="",d=!0;if(s.existsSync(u))try{f=s.readFileSync(u,"utf8"),d=!1}catch(e){d=!0}const m=o.join(e.workdir(),".git","config");let p="",w=!0;if(s.existsSync(m))try{p=s.readFileSync(m,"utf8"),w=!1}catch(e){w=!0}const h=(await e.getRemotes()).map(e=>"string"==typeof e?e:e&&"function"==typeof e.name?e.name():"?"),g=[];for(const e of h){const a=`remote.${e}`;let r="",n="",o="";try{r=await t.getString(a+".url")}catch(e){i.default.e(e)}try{n=await t.getString(a+".pushurl")}catch(e){i.default.e(e)}try{o=await t.getString(a+".fetch")}catch(e){i.default.e(e)}g.push({name:e,url:r,pushurl:n,fetch:o})}return{workdir:e.workdir(),name:r,user:{email:n,name:c},gitignore:{na:d,content:f},rawConfig:{na:w,content:p},remotes:g}},t.getRemoteOptions=async function(e,t){!function(e){if("ssh-key-specific"===e.credentialType){if(!e.sshCredentialDetail)throw new Error("SSH Public or Private key not provided");const t=e.sshCredentialDetail;if(!t.privateKeyPath||!t.publicKeyPath)throw new Error("SSH Public or Private key path not provided");if(!s.existsSync(t.publicKeyPath))throw new Error("SSH Public key file not found");if(!s.lstatSync(t.publicKeyPath).isFile())throw new Error("Given SSH Public key path is not a file");if(!s.existsSync(t.privateKeyPath))throw new Error("SSH Private key file not found");if(!s.lstatSync(t.privateKeyPath).isFile())throw new Error("Given SSH Private key path is not a file")}}(t);const a=await c.getCredentialStore(e);let n=0,o=!1;const u=e=>{switch(!0){case n<2:return r.Cred.defaultNew();case n<4:return r.Cred.sshKeyFromAgent(e)}return r.Cred.defaultNew()},l=(e,t)=>{if(!a)return u(t);const n=a.findIndex(t=>e.startsWith(t.url));if(n<0)return u(t);const i=a[n];return i.username&&i.password?r.Cred.userpassPlaintextNew(i.username,i.password):u(t)};return{callbacks:{credentials(e,a){if(o||++n>5){const e=new Error("credentials callback max loop reached, please check your credential settings.");return i.default.e(e),t.credentialRejector(e),o=!0,r.Cred.defaultNew()}try{if("default"===t.credentialType)return l(e,a);if("ssh-key"===t.credentialType)return r.Cred.sshKeyFromAgent(a);if("user-pass"===t.credentialType){if(!t.userPassCredentialDetail)return l(e,a);const n=t.userPassCredentialDetail;return r.Cred.userpassPlaintextNew(n.username,n.password)}if("ssh-key-specific"===t.credentialType){if(!t.sshCredentialDetail)return l(e,a);const n=t.sshCredentialDetail;return r.Cred.sshKeyNew(a,n.publicKeyPath,n.privateKeyPath,n.passPhrase)}}catch(e){return t.credentialRejector(e),r.Cred.defaultNew()}return l(e,a)},certificateCheck:()=>t.certificateCheck?1:0,transferProgress:{waitForResult:!0,throttle:500,callback(e){if(t.processCallback(e,()=>{o=!1}),o)return-1}},pushUpdateReference:(e,a)=>a?(t.pushUpdateRejector(a,e),-1):0},proxyOpts:t.proxyOpts,downloadTags:3,prune:1}},t.getProxyOptsForRemote=async function(e,t,a,o,s){if(o=o||"",!await e.getRemote(t))throw new Error("cannot find remote "+t);if("specific"===s){let e=r.Proxy.PROXY.SPECIFIED;return o||(e=r.Proxy.PROXY.NONE),{credentials:(e,t)=>r.Cred.defaultNew(),type:e,url:o}}const c=a,u=await l(e),f=n(c)||{};let d,m,p,w;try{d=await u.getString("http.proxy")}catch(e){i.default.e(e)}try{m=await u.getString(`http.${f.protocol}://${f.resource}.proxy`)}catch(e){i.default.e(e)}try{const e=await r.Config.openDefault();p=await e.getString(`http.${f.protocol}://${f.resource}.proxy`)}catch(e){i.default.e(e)}try{w=await u.getString(`remote.${t}.proxy`)}catch(e){i.default.e(e)}const h="string"==typeof w?w:"string"==typeof m?m:"string"==typeof p?p:d,g=f.protocol;let y=null;"http"===g?y=process.env.http_proxy||process.env.HTTP_PROXY||null:"https"===g&&(y=process.env.https_proxy||process.env.HTTPS_PROXY||null);const S="string"==typeof h||"string"==typeof y||!o;let C=""===h?r.Proxy.PROXY.NONE:S?r.Proxy.PROXY.AUTO:r.Proxy.PROXY.SPECIFIED;return C!==r.Proxy.PROXY.SPECIFIED||o||(C=r.Proxy.PROXY.NONE),{credentials:(e,t)=>r.Cred.defaultNew(),type:C,url:C===r.Proxy.PROXY.SPECIFIED?o:null}}},function(e,t){e.exports=require("git-url-parse")},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(2),i=a(6),o=a(3),s=a(39),c=a(1),u=a(19),l="win32"!==process.platform;let f=s.homedir().replace("\\","/");f.endsWith("/")||(f+="/"),t.getCredentialStore=async function(e){let t,a;try{t=await e.config()}catch(e){t=await r.Config.openDefault()}try{a=await t.getString("credential.helper")}catch(e){c.default.e(e)}let s=n.join(f,".git-credentials");if("string"==typeof a&&a.indexOf("--file")>=0){const e=a.split("--file");e&&"string"==typeof e[1]&&(s=e[1].trimLeft()),l&&(s=s.replace(/^\~\//,f))}if(i.existsSync(s)&&(e=>{try{return i.lstatSync(e)}catch(e){return c.default.e(e),{isFile:()=>!1}}})(s).isFile()){const e=/\r?\n/g,t=i.readFileSync(s,"utf8").split(e);return o.compact(t.map(e=>{try{const t=u(e),a=t.owner,r=t.user,n=r.split(":");let i,o;return"string"==typeof n[0]&&(i=decodeURIComponent(n[0])),"string"==typeof n[1]&&(o=decodeURIComponent(n[1])),{protocol:t.protocol,owner:a,user:r,resource:t.resource,url:t.protocol+"://"+t.resource,username:i,password:o}}catch(e){c.default.e(e)}}))}return null}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(5),i=a(40),o=a(4),s=a(11);function c(e){return e?(e.commit.parents()||[])[1]:null}t.getStashOid=c,t.getStashes=async function(e){const t=[];return await r.Stash.foreach(e,(a,s,u)=>{t.push(async function(e,t,a,s){const u=await r.Commit.lookup(e,s),l=await n.getCommitRecordFromCommit(u),f=o.toStringIfPossible(c({commit:u})||"");return i.getStashRecord(t,o.toStringIfPossible(s),a,l,f)}(e,a,s,u))}),(await Promise.all(t)).slice(0,250)},t.apply=async function(e,t,a=!0){await r.Stash.apply(e,t);const n=await e.index();n&&!n.hasConflicts()&&a&&await r.Stash.drop(e,t)},t.drop=async function(e,t){await r.Stash.drop(e,t)},t.stash=async function(e,t){return await s.stageWorkdirChanges(e),await r.Stash.save(e,e.defaultSignature(),t,0)}},function(e,t,a){e.exports=a(23)},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(24),n=a(25);t.handler=async function(e){if("string"!=typeof e)throw new Error("Not string");const t=JSON.parse(e);let a;try{const e=await n.default(t);return a={id:t.id,result:e}}catch(e){return a={id:t.id,error:{code:e.code?e.code:-1,message:e.toString?e.toString():String(e),data:e.data?e.data:void 0}}}};const i=process.env.wsport||"";if(!isNaN(parseInt(i))){let e;console.log("under port mode, opening 127.0.0.1 @",i),new r.Server({perMessageDeflate:!1,port:parseInt(i,10)},()=>{process.send&&process.send({__ready:!0})}).on("connection",t=>(function(t){(e=t).on("message",async e=>{if("string"!=typeof e)return;const a=JSON.parse(e);let r;try{const e=await n.default(a);r={id:a.id,result:e},t.send(JSON.stringify(r))}catch(e){r={id:a.id,error:{code:e.code?e.code:-1,message:e.toString?e.toString():String(e),data:e.data?e.data:void 0}},t.send(JSON.stringify(r))}})})(t))}},function(e,t){e.exports=require("ws")},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(12),i=a(7),o=a(3),s=a(4),c=a(1),u=a(30),l=a(31),f=a(34),d=a(36),m=a(5),p=a(11),w=a(16),h=a(41),g=a(10),y=a(18),S=a(21),C=a(6),b=a(2);t.default=async function(e){switch(e.method){case"git.freeAll":try{return await n.freeAll()}catch(e){throw e}case"git.initRepo":try{return await async function(e){return await l.init(e.dir,e.autoCommit,e.autoGitignore),n.returnBack(e.dir),{}}(e.params)}catch(t){throw n.returnBack(e.params.dir),t}case"git.repoDetect":try{return await async function(e){if(!C.existsSync(e))return{repoDetected:!1,isDir:!1,exists:!1};if(!C.lstatSync(e).isDirectory())return{repoDetected:!1,isDir:!1,exists:!0};try{const t=await r.Repository.open(e);t.free()}catch(e){let t=e&&e.toString&&e.toString();if(t&&(t=t.toLowerCase()).includes("could not find repository"))return{repoDetected:!1,isDir:!0,exists:!0};throw e}return{repoDetected:!0,isDir:!0,exists:!0}}(e.params.dir)}catch(t){throw n.returnBack(e.params.dir),t}case"git.saveBlobContent":try{return await async function(e){const t=await n.default(e.dir);if(e.blobSha)await f.saveBlobContent(t,e.blobSha,e.saveFilePath);else{const a=await t.getCommit(e.commitSha),r=await a.getEntry(e.filePath);await f.saveBlobContent(t,r.sha(),e.saveFilePath),r.free(),a.free()}return n.returnBack(e.dir),{}}(e.params)}catch(t){throw n.returnBack(e.params.dir),t}case"git.fileHistoryWalk":try{return await async function(e){const t=await n.default(e.dir);if(!e.fromSha||"head"===e.fromSha.toLowerCase()){const a=await t.getHeadCommit();e.fromSha=a.sha()}const a=await h.walkForFile(t,e.filePath,e.fromSha,e.max);return n.returnBack(e.dir),{fileHistoryWalks:a}}(e.params)}catch(t){throw n.returnBack(e.params.dir),t}case"git.checkoutFiles":try{return await async function(e){const t=await n.default(e.dir);if(!e.commitSha){const a=await t.getHeadCommit();e.commitSha=a.sha()}return await u.checkoutFiles(t,e.rPaths,e.commitSha),n.returnBack(e.dir),{}}(e.params)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getCommitTree":try{return await async function(e){const t=await n.default(e.dir),a=await f.getCommitTree(t,e.commitSha,e.path);return n.returnBack(e.dir),{treeRecords:a}}(e.params)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getBlobContent":try{return await async function(e){const t=await n.default(e.dir);let a;if(e.blobSha)a=await f.getBlobContent(t,e.blobSha);else{const r=await t.getCommit(e.commitSha),n=await r.getEntry(e.filePath);a=await f.getBlobContent(t,n.sha()),n.free(),r.free()}return n.returnBack(e.dir),{blobRecord:a}}(e.params)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getWorkdirChanges":try{return await async function(e){const t=await n.default(e),a=await i.getStatus(t);return n.returnBack(e),{workdirChanges:a}}(e.params.dir)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getWorkdirDiff":try{return await async function(e,t,a){const r=await n.default(e),i=t&&t.length?t:void 0,o=await d.getWorkdirDiffs(r,i,a);return n.returnBack(e),{workdirDiffs:o}}(e.params.dir,e.params.rPaths,e.params.options)}catch(t){throw n.returnBack(e.params.dir),t}case"git.toggleStagePath":try{return await async function(e,t,a){const r=await n.default(e),o=await i.getStatus(r);if(!o.changes[t])throw new Error(t+" has not changed");return a===Boolean(o.changes[t].isStaged)?{}:a?(await p.stage(r,[t]),n.returnBack(e),{}):(await p.unstage(r,[t]),n.returnBack(e),{})}(e.params.dir,e.params.path,e.params.stage)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getRefNames":try{return await async function(e){const t=await n.default(e),a=await w.getRefNamesOrdered(t);return n.returnBack(e),{refNames:a}}(e.params.dir)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getRefCommits":try{return await async function(e){const t=await n.default(e),a=await w.getAllRefCommits(t);return n.returnBack(e),{refCommits:a}}(e.params.dir)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getSubmodules":try{return await async function(e){const t=await n.default(e),a=await g.getSubmoduleRecords(t);return n.returnBack(e),{submodules:a}}(e.params.dir)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getRevwalks":try{return await async function(e,t,a,r){const i=await n.default(e);let o;return o=a?await h.walkFromAll(i,r):await h.walkFromSha(i,t,r),n.returnBack(e),{revwalks:o}}(e.params.dir,e.params.startingShas,e.params.walkFromAll,e.params.max)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getCommitDiffs":try{return await async function(e,t,a){const r=await n.default(e),i=await d.getDiffsForCommit(r,t,a);return n.returnBack(e),{diffs:i}}(e.params.dir,e.params.commitSha,e.params.options)}catch(t){throw n.returnBack(e.params.dir),t}case"git.stageAll":try{return await async function(e,t){const a=await n.default(e),r=async()=>o.values((await i.getStatus(a)).changes);let s=await r();if(t)for(;s.findIndex(e=>e.isUnstaged)>=0;)await p.stageWorkdirChanges(a),s=await r();else for(;s.findIndex(e=>e.isStaged)>=0;)await p.unstageWorkdirChanges(a),s=await r();return n.returnBack(e),{}}(e.params.dir,e.params.stage)}catch(t){throw n.returnBack(e.params.dir),t}case"git.commit":try{return await async function(e,t){const a=await n.default(e),r=await a.index();return await m.commit(a,r,t),n.returnBack(e),{}}(e.params.dir,e.params.message)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getRepoConfigOverview":try{return await async function(e){const t=await n.default(e),a=await y.getRepoConfigOverviewForRepo(t);return n.returnBack(e),{overview:a}}(e.params.dir)}catch(t){throw n.returnBack(e.params.dir),t}case"git.readFile":try{const t=b.join(...e.params.pathFragments);return C.existsSync(t)?{content:C.readFileSync(t,"utf8"),notFound:!1}:{content:"",notFound:!0}}catch(e){throw e}case"git.setRepoConfig":try{return await async function(e,t){const a=await n.default(e);return await y.setConfigForRepo(a,t),n.returnBack(e),{}}(e.params.dir,e.params.configs)}catch(t){throw n.returnBack(e.params.dir),t}case"git.getStashes":try{return await async function(e){const t=await n.default(e),a=await S.getStashes(t);return n.returnBack(e),{stashes:a}}(e.params.dir)}catch(t){throw n.returnBack(e.params.dir),t}case"git.saveStash":try{return await async function(e,t){const a=await n.default(e);return await S.stash(a,t),n.returnBack(e),{}}(e.params.dir,e.params.message)}catch(t){throw n.returnBack(e.params.dir),t}case"git.applyStash":try{return await async function(e,t,a){const r=await n.default(e);return await S.apply(r,t,a),n.returnBack(e),{}}(e.params.dir,e.params.index,e.params.autoDrop)}catch(t){throw n.returnBack(e.params.dir),t}case"git.dropStash":try{return await async function(e,t){const a=await n.default(e);return await S.drop(a,t),n.returnBack(e),{}}(e.params.dir,e.params.index)}catch(t){throw n.returnBack(e.params.dir),t}case"git.checkoutBranch":try{return await async function(e,t){const a=await n.default(e);return await w.checkout(a,t),n.returnBack(e),{}}(e.params.dir,e.params.fullName)}catch(t){throw n.returnBack(e.params.dir),t}case"git.createBranch":try{return await async function(e,t,a,r){const i=await n.default(e);if(a){const e=await i.getReference(a),r=e.target();await w.create(i,t,s.toStringIfPossible(r))}else await w.create(i,t,r);return n.returnBack(e),{}}(e.params.dir,e.params.newBranchFullName,e.params.branchFullName,e.params.commitSha)}catch(t){throw n.returnBack(e.params.dir),t}case"git.deleteBranch":try{return await async function(e,t){const a=await n.default(e);return await w.delete_(a,t),n.returnBack(e),{}}(e.params.dir,e.params.branchFullName)}catch(t){throw n.returnBack(e.params.dir),t}case"git.resetWorkdir":try{return await async function(e,t,a){const r=await n.default(e);if(t)await u.reset(r,t,k(a));else{const e=await r.getHeadCommit();await u.reset(r,e.sha(),k(a))}return n.returnBack(e),{}}(e.params.dir,e.params.commitSha,e.params.type)}catch(t){throw n.returnBack(e.params.dir),t}case"git.resetFiles":try{return await async function(e,t){const a=await n.default(e);return await u.resetFiles(a,t),n.returnBack(e),{}}(e.params.dir,e.params.rPaths)}catch(t){throw n.returnBack(e.params.dir),t}case"git.addRemote":try{return await async function(e,t,a,r){const i=await n.default(e);return r?await w.addRemote(i,t,a,r):await w.addRemote(i,t,a),n.returnBack(e),{}}(e.params.dir,e.params.name,e.params.url,e.params.fetchSpec)}catch(t){throw n.returnBack(e.params.dir),t}case"git.fetchRemote":try{return await async function(e,t,a,r){const i=await n.default(e);if(t){const e=[],t=await w.getRemoteRefNames(i);for(const a of t)try{await w.fetch(i,a,null,Object.assign({},r,{processCallback:c.default.i}))}catch(t){e.push(t)}if(e.length>0)throw e.join("; ")}else await w.fetch(i,a,null,Object.assign({},r,{processCallback:c.default.i}));return n.returnBack(e),{}}(e.params.dir,e.params.fetchAll,e.params.remoteOriginName,e.params.networkCredential)}catch(t){throw n.returnBack(e.params.dir),t}case"git.pull":try{return await async function(e){const t=await n.default(e.dir);return await w.pull(t,e.remoteRefFullName,{type:e.pullType,rebaseProcessCallback:c.default.i,fetchOptions:Object.assign({},e.networkCredential,{processCallback:c.default.i})}),n.returnBack(e.dir),{}}(e.params)}catch(t){throw n.returnBack(e.params.dir),t}case"git.push":try{return await async function(e){const t=await n.default(e.dir);return await w.push(t,e.localRefFullName,e.remoteRefFullName,Object.assign({},e.networkCredential,{force:e.force,processCallback:c.default.i})),n.returnBack(e.dir),{}}(e.params)}catch(t){throw n.returnBack(e.params.dir),t}case"git.setUpstream":try{return await async function(e){const t=await n.default(e.dir);return e.unset?await w.setUpstream(t,e.localRefFullName,""):await w.setUpstream(t,e.localRefFullName,e.remoteRefFullName),n.returnBack(e.dir),{}}(e.params)}catch(t){throw n.returnBack(e.params.dir),t}case"git.merge":try{return await async function(e){const t=R(e.mergePreference),a=await n.default(e.dir),r=await a.head();return await w.merge(a,r.name(),e.theirRefFullName,{preference:t}),n.returnBack(e.dir),{}}(e.params)}catch(t){throw n.returnBack(e.params.dir),t}}throw new Error("method "+e.method+" was not found")};const k=e=>{switch(e){case"hard":return 3;case"mixed":return 2}return 1};const R=e=>{switch(e){case"no-ff":return 1;case"ff-only":return 2}return 0}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});a(0);const r=a(13);function n(e,t="INDEX"){return e.includes(`${t}_NEW`)?r.DiffType.ADDED:e.includes(`${t}_DELETED`)?r.DiffType.DELETED:e.includes(`${t}_MODIFIED`)?r.DiffType.MODIFIED:e.includes(`${t}_RENAMED`)?r.DiffType.RENAMED:null}function i(e){const t=e&&e.newFile(),a=t&&t.id();return a&&a.toString()||""}t.isSubmoduleCommit=function(e,t){return 57344===e||57344===t},t.getStatusFromNodeGitStatus=n,t.extractHash=i,t.fromStatus=function(e){const t=e.isConflicted();let a=null,r=null;t||(a=n(e.status(),"INDEX"),r=n(e.status(),"WT"));const o=Boolean(e.isRenamed());let s=null;o&&(e.inWorkingTree()?s=e.indexToWorkdir().oldFile().path():e.inIndex()&&(s=e.headToIndex().oldFile().path()));const c=e.headToIndex(),u=e.indexToWorkdir();return{path:e.path(),name:e.path(),isConflicted:t,isStaged:e.inIndex(),isUnstaged:e.inWorkingTree(),stagedHash:i(e.headToIndex()),unstagedHash:i(e.indexToWorkdir()),stagesStatus:a,unstagedStatus:r,isRenamed:o,oldFileName:s,originallyConflicted:!1,fileModes:{staged:{new:c&&c.newFile().mode(),old:c&&c.oldFile().mode()},unstaged:{new:u&&u.newFile().mode(),old:u&&u.oldFile().mode()}},submoduleCommit:{staged:!1,unstaged:!1},isSubmoduleCommit:!1,descriptor:{inIndex:e.inIndex(),inWorkingTree:e.inWorkingTree(),isConflicted:e.isConflicted(),isDeleted:e.isDeleted(),isIgnored:e.isIgnored(),isModified:e.isModified(),isNew:e.isNew(),isRenamed:e.isRenamed(),isTypechange:e.isTypechange(),path:e.path(),status:e.status(),statusBit:e.statusBit()}}}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(1),i=a(4),o=a(3),s=a(5);t.fromSubmodule=async function(e){const t=await r.Submodule.status(e.owner(),e.name(),1);let a=null;try{a=await e.open()}catch(e){n.default.e("open submodule fail",e),a=null}const c=i.toStringIfPossible(e.headId()),u=i.toStringIfPossible(e.indexId()),l=i.toStringIfPossible(e.wdId()),f=o.uniq(o.compact([c,u,l]));if(!a)return{headId:c,indexId:u,wdId:l,status:t,commitShas:f};const d=await Promise.all(f.map(async e=>{try{const t=await a.getCommit(e);return await s.getCommitRecordFromCommit(t)}catch(e){return n.default.e(e),null}})),m=o(d).compact().keyBy("sha").value();let p=null;if(c&&l&&c!==l&&m[c]&&m[l])try{p=await r.Graph.aheadBehind(a,e.wdId(),e.headId())}catch(e){p=null}const w={name:e.name(),url:e.url(),path:e.path(),updateStrategy:e.updateStrategy(),status:t,ignore:e.ignore(),ownerPath:e.owner().path(),headId:c,indexId:u,wdId:l,commits:m,ahead:p?p.ahead:void 0,behind:p?p.behind:void 0,commitShas:f,isDeleted:!1,isUninitialized:!1,isOutOfSync:!1,isInPerfectSync:!1,isNew:!1,isInConfig:!1,isDirty:!1,workdirSha:"",pointerSha:""};return w.isDeleted=Boolean(544&t)&&!(8&t),w.isUninitialized=Boolean(128&t)||!w.isDeleted&&void 0===l,w.isOutOfSync=Boolean(1904&t),w.isUninitialized||c===u&&c===l||(w.isOutOfSync=!0),w.isDirty=Boolean(6144&t),w.isInPerfectSync=!w.isOutOfSync&&!w.isDirty&&!w.isUninitialized,w.isNew=!(1&t),w.isInConfig=Boolean(4&t),w.isOutOfSync?w.isDeleted?w.pointerSha=c:(w.workdirSha=l,w.isNew||(w.pointerSha=c)):w.workdirSha=c,a&&(a.free(),a=null),w}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(4),n=a(29);function i(e){const t={full:"",date:-1,email:"",name:""};if(!e)return t;const a=r.safeInvoke(e.when,e)();return a&&(t.date=1e3*a.time()),t.full=r.toStringIfPossible(e),t.name=r.safeInvoke(e.name,e,"")(),t.email=r.safeInvoke(e.email,e,"")(),t}t.getSignatureDetail=i,t.fromCommit=async function(e){const t=await Promise.all(e.parents().map(e=>r.toStringIfPossible(e))),a=i(r.safeInvoke(e.author,e)()),o=i(r.safeInvoke(e.committer,e)()),s=t.length>1?n.NodeType.MergeNodeType:n.NodeType.CommitNodeType;return{sha:e.sha(),message:e.message(),type:s,secondaryTypes:null,parents:t,authorDetail:a,committerDetail:o}}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.MergeNodeType="MergeNodeType",e.CommitNodeType="CommitNodeType"}(t.NodeType||(t.NodeType={}))},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(1),i=a(8),o=a(2),s=a(10),c=a(7),u=a(14);async function l(e,t){for(const a of t)if(a.isDeleted)await f(e,[a.path]);else try{const t=await r.Submodule.lookup(e,a.name),s=await t.open(),c=await t.headId(),u=await r.Commit.lookup(s,c);await r.Reset.reset(s,u,3);const l=[];await r.Status.foreach(s,(e,t)=>{128===t&&l.push(i.remove(o.join(s.workdir(),e)))}),await l,s.free()}catch(e){n.default.e(e)}}async function f(e,t,a){if(a){const n=await e.getCommit(a),i=await n.getTree();await r.Checkout.tree(e,i,{paths:t,checkoutStrategy:2})}else await r.Checkout.head(e,{paths:t,checkoutStrategy:2})}t.reset=async function(e,t,a){const n=await e.getCommit(t);if(!n)throw new Error("Cannot find specific commit "+t);await r.Reset.reset(e,n,a)},t.resetFiles=async function(e,t){const a=[],n=[],d=[],m=[],p=[],w=await s.getSubmoduleRecords(e),h=await c.getStatus(e);for(const e of t)if(w.findIndex(t=>t.path===e&&(m.push(t),!0))>=0)d.push(e),a.push(e);else if(h.changes[e]&&h.changes[e].oldFileName){const t=h.changes[e].oldFileName;n.push(e),p.push(t),a.push(t),a.push(e)}else p.push(e),a.push(e);if(u.deleteLock(e),m.length>0&&await l(e,m),0===a.length||p.length>0){const t=p;await f(e,t)}for(const t of n){const a=o.join(e.workdir(),t);i.existsSync(a)&&128===await r.Status.file(e,t)&&i.removeSync(a)}},t.resetSubmodules=l,t.checkoutFiles=f},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(8),i=a(2),o=a(32),s=a(12),c=a(1),u=a(11),l=a(5),f=a(33);t.init=async function(e,t,a){let d;try{d=await s.default(e)}catch(t){const a=r.Repository.INIT_FLAG.NO_REINIT|r.Repository.INIT_FLAG.MKPATH|r.Repository.INIT_FLAG.MKDIR;d=await r.Repository.initExt(e,{flags:a})}if(!d.isEmpty())throw new o.default(-1,"repo already exists");a&&await async function(e){const t=i.normalize(e.workdir()),a=i.join(t,".gitignore");if(!n.existsSync(a)){c.default.i("auto gitignore");const e=process.platform,t="win32"===e?f.default.win32():f.default.unixLike();n.writeFileSync(a,t,"utf-8")}}(d),t&&await async function(e){await u.addAll(e);const t=await e.index();await l.commit(e,t,"Initial Commit")}(d)}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=class{constructor(e,t,a){this.code=e,this.message=t,this.error=a,this.stack=(new Error).stack||""}}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=["# Windows","[Dd]esktop.ini","Thumbs.db","$RECYCLE.BIN/","","# macOS",".DS_Store",".fseventsd",".Spotlight-V100",".TemporaryItems",".Trashes","","# Node.js","node_modules/",""];t.default={win32:()=>r.join("\r\n"),unixLike:()=>r.join("\n")}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(35),n=a(2),i=a(8);t.getCommitTree=async function(e,t,a){const r=await e.getCommit(t),i=await r.getTree();let o;if(a){const t=await i.entryByPath(a);if(!t.isTree())throw i.free(),new Error(a+" is not a directory");const r=await e.getTree(t.id());o=await r.entries()}else o=await i.entries();const s=[];for(const e of o)s.push({isDirectory:e.isDirectory(),isFile:e.isFile(),isSubmodule:e.isSubmodule(),isTree:e.isTree(),path:a?n.posix.join(a,e.name()):e.path(),name:e.name(),isBlob:e.isBlob(),type:e.type(),sha:e.sha()});return i.free(),o.forEach(e=>e.free()),r.free(),s},t.MaxBlobLength=1048576,t.saveBlobContent=async function(e,t,a){const r=await e.getBlob(t);if(!r)throw new Error("Cannot find blob "+t);const n=r.content();await i.writeFile(a,n),r.free()},t.getBlobContent=async function(e,a){const n=await e.getBlob(a);if(!n)throw new Error("Cannot find blob "+a);const i=n.content(),o=r(i.slice(0,13)),s=i.length>t.MaxBlobLength,c=i.slice(0,t.MaxBlobLength),u=o&&o.mime||"",l=u.includes("image");let f,d;l?(f=!0,d=s?"":c.toString("base64")):(f=!1,d=c.toString("utf8").replace(/\ /g," ").replace(/\t/g,"    "));const m=i.byteLength,p=c.byteLength,w=Boolean(n.isBinary());return n.free(),{isBinary:w,isImage:l,byteLength:m,content:d,mime:u,slicedLength:p,base64Encoded:f}}},function(e,t){e.exports=require("image-type")},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(37),i=a(7);t.getDiffsForCommit=async function(e,t,a={}){const i={flags:a.ignoreWhiteSpace?4194304:0};if(0!=(1&(await e.index()).caps())&&(i.flags|=1024),!(t=await r.Commit.lookup(e,t)))throw new Error("cannot find specific commit "+t);const o=await t.getDiffWithOptions(i),s=o&&o[0];if(!s)throw new Error("cannot find diffs for commit "+t);await s.findSimilar(i);const c=await n.getParsedDiffsfromDiff(s);let u=0,l=0,f=0,d=0;for(const e of c)switch(e.type){case n.DiffTypes.Added:u+=1;break;case n.DiffTypes.Deleted:l+=1;break;case n.DiffTypes.Modified:f+=1;break;case n.DiffTypes.Renamed:d+=1}return{sha:t.sha(),added:u,deleted:l,modified:f,renamed:d,opts:a,diffOpts:i,parsedDiffs:c}},t.getDiffsForContent=async function(e,t,a,n={}){let i;if(n.compareTarget&&"head"===n.compareTarget){const t=await e.getHeadCommit(),r=await t.getEntry(a);i=await r.getBlob()}else{const t=await e.index(),r=await t.getByPath(a,0);i=await e.getBlob(r.id)}const o={contextLines:0,flags:n.ignoreWhiteSpace?4194304:0};0!=(1&(await e.index()).caps())&&(o.flags|=1024);const s=[],c=new Promise((e,n)=>{r.Diff.blobToBuffer(i,a,t,a,o,null,null,(()=>(function(e,t,a){s.push({newStart:t.newStart(),newLines:t.newLines(),oldStart:t.oldStart(),oldLines:t.oldLines(),header:t.header()})}))(),null).then(e,e)});return await c,s},t.getWorkdirDiffs=async function(e,t,a={}){const o={flags:33554448},s={flags:0};a.ignoreWhiteSpace&&(s.flags|=4194304,o.flags|=4194304),t&&t.length>0&&(s.pathspec=t,o.pathspec=t);const c=await e.getHeadCommit();if(!c)return{parsedStagedDiffs:[],parsedUnstagedDiffs:[],parsedConflictedDiffs:[]};const u=await c.getTree(),l=await r.Diff.treeToIndex(e,u,null,s),f=await r.Diff.indexToWorkdir(e,null,o),d=await r.Diff.treeToWorkdir(e,u,s),m=await n.getParsedDiffsfromDiff(l),p=await n.getParsedDiffsfromDiff(f),w=await n.getParsedDiffsfromDiff(d),h=(await i.getStatus(e)).changes,g={};for(const e in h)h[e].isConflicted&&(g[h[e].path]=!0);return{parsedStagedDiffs:m,parsedUnstagedDiffs:p,parsedConflictedDiffs:w.filter(e=>g[e.path])}}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});a(0);const r=a(15);var n=a(15);async function i(e){if(!e)return[];const t=await e.hunks(),a=[];for(const e of t){const t=(await e.lines()).map(e=>{const t=e.oldLineno(),a=e.newLineno(),n=String.fromCharCode(e.origin());let i,o=String(t),s=String(a);return-1===t?o=" ":"-"===n&&(o=n+t),-1===a?s=" ":"+"===n&&(s=n+a),{oldLineNo:t,newLineNo:a,oldNo:o,newNo:s,type:i="+"===n?r.LineTypes.Added:"-"===n?r.LineTypes.Deleted:r.LineTypes.NotModified,content:e.content().split(" ").join(" ").split("\t").join("    ").split("\n").join(" "),line:e}});a.push({header:e.header(),parsedLines:t,newLines:e.newLines(),newStart:e.newStart(),oldStart:e.oldStart(),oldLines:e.oldLines()})}return a}t.DiffTypes=n.DiffTypes,t.getParsedDiffsfromDiff=async function(e){const t=(await e.patches()||[]).filter(e=>!e.isUnmodified()),a=[];let n=0;for(const o of t){const t=o.newFile().path(),s=0!=(1&e.getDelta(n).flags());let c;c=o.isAdded()||o.isUntracked()?r.DiffTypes.Added:o.isDeleted()?r.DiffTypes.Deleted:o.isModified()?r.DiffTypes.Modified:o.isConflicted()?r.DiffTypes.Conflict:o.isRenamed()?r.DiffTypes.Renamed:r.DiffTypes.Unknown;const u=await i(o);a.push({name:t,type:c,patch:o,isBinary:s,path:t,parsedHunks:u,oldFilePath:o.oldFile().path(),oldFileSize:o.oldFile().size(),newFileSize:o.newFile().size()}),n+=1}return a},t.getParsedHunksForPatch=i},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=a(0),n=a(4);!function(e){for(var a in e)t.hasOwnProperty(a)||(t[a]=e[a])}(a(9));const i=a(9);t.getMergeState=async function(e,t,a){const o=await r.Merge.base(e,t,a);return n.toStringIfPossible(o)===n.toStringIfPossible(a)?i.MergeState.UpToDate:n.toStringIfPossible(o)===n.toStringIfPossible(t)?i.MergeState.FastForward:i.MergeState.Normal},t.rebaseReleaseObjCallback=function(e,t){const a=(t=t||{}).operationEntrycount&&t.operationEntrycount();let r=t.operationCurrent&&t.operationCurrent();(r>a||r<0)&&(r=0),e(r,a)}},function(e,t){e.exports=require("os")},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getStashRecord=function(e,t,a,r,n){return{index:e,sha:t,message:a,commit:r,modelSha:n}}},function(e,t,a){"use strict";Object.defineProperty(t,"__esModule",{value:!0});a(0);const r=a(5),n=a(16),i=a(3);async function o(e,t,a){const o=await t.fastWalk(a),s=await n.getAllRefCommits(e),c=i.keyBy(i.values(s),"sha"),u=[];for(const t of o){const a=await e.getCommit(t),n=await r.getCommitRecordFromCommit(a);c[n.sha]&&(n.refFullName=c[n.sha].refFullName),u.push(n),a.free()}return u}t.walkFromSha=async function(e,t,a=250){const r=await e.createRevWalk();return r.sorting(2),t.forEach(e=>e&&r.push(e)),await o(e,r,a)},t.walkFromHead=async function(e,t=250){const a=await e.createRevWalk();return a.sorting(2),a.pushHead(),await o(e,a,t)},t.walkFromRef=async function(e,t,a=250){const r=await e.createRevWalk();return r.sorting(2),r.pushRef(t),await o(e,r,a)},t.walkFromAll=async function(e,t=250){const a=await e.createRevWalk();return a.sorting(2),a.pushGlob("refs/**/*"),await o(e,a,t)};const s=500;t.walkForFile=async function(e,t,a,o=250){let c="",u=[];const l=[];for(;u.length<o;){const r=await e.createRevWalk();r.sorting(2),c?r.push(c):r.push(a);const n=await r.fileHistoryWalk(t,s);if(l.push(...n.map(e=>e.commit)),0===n.length)break;const i=n[n.length-1],f=n[0];if(1===n.length&&i.commit.sha()===c)break;c===f.commit.sha()&&n.shift(),c=i.commit.sha(),u.push(...n.map(e=>e.commit)),u=u.slice(0,o)}const f=await n.getAllRefCommits(e),d=i.keyBy(i.values(f),"sha"),m=[];for(const e of u){const t=await r.getCommitRecordFromCommit(e);d[t.sha]&&(t.refFullName=d[t.sha].refFullName),m.push(t)}return l.forEach(e=>e.free()),m}}]);
//# sourceMappingURL=bundle.js.map
